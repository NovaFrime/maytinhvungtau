[General TypeScript Guidelines]
Basic Principles
- Use English for all code, documentation, and comments.
- Always declare types for variables, function parameters, and return values.
- Avoid any → Use explicit types or generics.
- Encapsulate primitive types in structured types when necessary.
- Use JSDoc for public classes, functions, and modules.
- One export per file → Each file should contain a single class, function, or module.

Nomenclature
- Classes → PascalCase (e.g., AuthService)
- Variables, functions, methods → camelCase (e.g., getUserById)
- Directories & files → kebab-case (e.g., user-service.ts)
- Environment variables → UPPERCASE_SNAKE_CASE
- Boolean variables → Start with verbs (e.g., isLoading, hasError, canEdit)
- Avoid abbreviations → Except standard ones (API, URL, req, res, ctx, err).

Functions & Methods
- Keep functions short → Max 20 instructions, single responsibility.
- Start function names with verbs → fetchUsers(), validateInput(), executeJob().
- Use default parameters instead of checking for undefined or null.
- Reduce parameter count using RO-RO (Receive Object, Return Object).
- Use higher-order functions (map, filter, reduce) instead of deep loops.
- Use arrow functions for short functions (<3 lines), named functions otherwise.
- Avoid nesting → Use early returns, guard clauses, and utility functions.

Classes & Data Handling
- Follow SOLID principles.
- Prefer composition over inheritance.
- Use interfaces to define contracts for dependencies.
- Encapsulate validations inside classes, not scattered across functions.
- Prefer immutability (readonly, as const).

Error Handling
- Use exceptions only for unexpected errors.
- Use structured error classes instead of throwing generic Error().
- Global error handler → Centralized logging & response formatting.

[Next.js (Frontend) Guidelines]
Code Structure & Best Practices
- Use React Server Components (RSC) → Minimize 'use client'.
- State Management → Use Zustand or TanStack Query (avoid Redux).
- Data Fetching → Prefer server-side fetching over useEffect.
- Forms & Validation → Use React Hook Form + Zod.
- UI & Styling → Use Tailwind CSS + Shadcn UI + Radix UI (no inline styles).
- Performance → Optimize with lazy loading, dynamic imports, next/image.
- SEO → Implement proper <head> metadata and dynamic OpenGraph tags.
- Security → Use middleware for authentication, CSP headers, and input sanitization.

[NestJS (Backend) Guidelines]
Architecture
- Modular structure → Each domain has its own module (user.module.ts, auth.module.ts).
- Encapsulated services → Keep business logic in services, controllers for routing only.

Data Models
- DTOs → Use class-validator for input validation.
- Entities → Use Prisma (or MikroORM) for database persistence.

Authentication & Authorization
- Use NextAuth.js (JWT) or Clerk for API security.
- Use guards & decorators for role-based access control (RBAC).

Middleware & Interceptors
- Rate limiting → Prevent abuse.
- Logging → Use Pino for structured logs.
- Global Exception Filter → Standardize error responses.

API Design & Data Handling
- RESTful API structure → Use /users, /auth/login, /products/{id}.
- Use versioning (/v1/users) for API stability.
- Return DTOs, not raw database entities.
- Paginate results for large datasets.
- Cache frequently accessed data (e.g., Redis).

[Database & Caching]
- Use Prisma ORM → Define schema centrally (schema.prisma).
- Index frequently queried fields (@unique, @index).
- Avoid N+1 queries → Use select, include, and batch queries.
- Use Redis for caching common queries & authentication tokens.

[Security & Performance Best Practices]
- Environment Variables → Never hardcode secrets; use .env files.
- CORS Configuration → Restrict origins properly.
- Helmet Middleware → Secure HTTP headers.
- Input Validation → Sanitize all user inputs using Zod or class-validator.
- Rate Limiting → Prevent abuse (e.g., express-rate-limit).
- Lazy Loading → Split components/modules where needed.
- Use CDN for assets → Optimize image and script loading.

[Testing & Deployment]
Testing Strategy
- Unit Tests → Jest for components, services, and controllers.
- Integration Tests → Supertest for API endpoints.
- End-to-End Tests → Cypress or Playwright.
- Follow Arrange-Act-Assert pattern in test cases.
- Use test doubles (mocks, stubs, spies) for dependencies.

CI/CD & Deployment
- GitHub Actions for automation → Run linting, tests, and builds.

Deployment Strategy
- Frontend → Deploy Next.js on Vercel.
- Backend → Deploy NestJS on Fly.io/Railway.
- Database → Use PlanetScale/PostgreSQL with Prisma migrations.
- Monitor logs & errors → Use Sentry, LogRocket, or Datadog.

[Development Process]
1. Define Requirements → Break features into small tasks.
2. Plan Architecture → Structure API, database, and frontend components.
3. Implement Efficiently → Follow clean code & modularity principles.
4. Test & Optimize → Ensure reliability before deployment.